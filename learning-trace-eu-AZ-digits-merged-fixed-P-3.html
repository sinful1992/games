<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Learning Adventure ‚Äî Tracing (European Style)</title>
<style>
  *{box-sizing:border-box;user-select:none;-webkit-user-select:none}
  html,body{margin:0;padding:0}
  body{height:100dvh;display:flex;align-items:center;justify-content:center;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
  #wrap{width:100vw;height:100dvh;background:#fff0;position:relative;overflow:hidden}
  canvas{width:100%;height:100%;display:block;touch-action:none}
  #scoreBox{position:absolute;top:8px;right:8px;background:linear-gradient(135deg,#fff,#ffe4b5);border-radius:14px;padding:6px 10px;font-weight:700;z-index:3;font-size:clamp(12px, 3vw, 18px)}
  #timer{display:none}
  #title{position:absolute;top:10px;left:50%;transform:translateX(-50%);font:700 clamp(16px,3.2vw,28px) system-ui, Arial;color:#333;z-index:2}
</style>
</head>
<body>
<div id="wrap">
  <div id="title">Loading‚Ä¶</div>
  <div id="scoreBox">Points: <span id="score">0</span> ‚≠ê</div>
  <canvas id="c"></canvas>
</div>
<script>
// rAF polyfill (older Androids)
window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(cb){return setTimeout(cb,16)};

const canvas = document.getElementById('c'); const ctx = canvas.getContext('2d',{alpha:false});
let screenScale = 1;

function fit(){
  const dpr=Math.max(1,window.devicePixelRatio||1); 
  const w = Math.max(1, Math.floor(window.innerWidth * dpr));
  const h = Math.max(1, Math.floor(window.innerHeight * dpr));
  if(canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h; 
  }
  ctx.setTransform(dpr,0,0,dpr,0,0);
  const sx = window.innerWidth/1024;
  const sy = window.innerHeight/768;
  screenScale = Math.min(Math.max(Math.min(sx, sy), 0.42), 1.6);
} 
['resize','orientationchange','visibilitychange'].forEach(evt=>addEventListener(evt,fit,{passive:true}));
fit();

// ===== state
let score=0; const scoreEl=document.getElementById('score');
let mode='count'; // count | trace
let animals=[];
let parts=[];

// TRACING (with optional pen-lifts)
let tracingStrokes=[];   // Array<Array<{x,y}>>
let strokeIdx=0;         // current stroke index
let pointIdx=0;          // progress within current stroke
let completedStrokes=0;  // number of finished strokes
let pointerDown=false;
let currentNumber=1, currentLetter=0, tracingSet='numbers';
const lettersList='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

// Enhanced tracing state
let userStrokes = [];  // User's drawn strokes
let currentUserStroke = [];  // Current stroke being drawn
let tracingCoverage = [];  // Coverage map for each target stroke

// No-repeat queues
const RECENT_LEN=3; const recentNumbers=[]; const recentLetters=[]; const recentCounts=[];
function pushRecent(arr,v){arr.push(v); while(arr.length>RECENT_LEN) arr.shift();}
function nextUnique(list, recent){const choices=list.filter(v=>!recent.includes(v)); if(!choices.length){recent.length=0; return list[(Math.random()*list.length)|0];} return choices[(Math.random()*choices.length)|0];}

// ===== sfx / particles
let audioContext = null;
function ensureAudio(){ if(!audioContext){ const AC = window.AudioContext||window.webkitAudioContext; if(AC){ audioContext = new AC(); } } }
function beep(f,d){ try{ ensureAudio(); if(!audioContext) return; const o=audioContext.createOscillator(),g=audioContext.createGain();o.type='sine';o.frequency.value=f;o.connect(g);g.connect(audioContext.destination);const t=audioContext.currentTime;g.gain.setValueAtTime(.25,t);g.gain.exponentialRampToValueAtTime(.01,t+d);o.start(t);o.stop(t+d);}catch{}}
const sClick=()=>beep(440,.08), sOK=()=>{beep(523,.08); setTimeout(()=>beep(659,.08),80); setTimeout(()=>beep(784,.12),160);};

function burst(x,y,n=10){ for(let i=0;i<n;i++){parts.push({x,y,vx:(Math.random()-.5)*7,vy:(Math.random()-.5)*7,a:1,r:Math.random()*7+4,c:`hsl(${Math.random()*360},70%,60%)`});} }

// ===== counting (emoji-safe font stack)
const EMOJI_FONT = '"Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",system-ui,Arial,sans-serif';
class Animal{
  constructor(x,y,e){
    this.x=x;this.y=y;this.e=e;
    this.s=84*screenScale;
    this.counted=false;
    this.b=0;
  } 
  draw(){
    ctx.save();
    ctx.translate(this.x,this.y+this.b);
    ctx.font=`${this.s}px ${EMOJI_FONT}`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.globalAlpha=this.counted?.5:1;
    ctx.fillText(this.e,0,0);
    ctx.restore(); 
    if(!this.counted) this.b=Math.sin(Date.now()/480+this.x)*7;
  } 
  hit(x,y){return Math.hypot(x-this.x,y-this.y)<this.s/2;}
}

function initCount(){ 
  animals=[]; 
  const types=['üêÑ','üê∑','üêî','üêë','üê¥','ü¶Ü','üêê','üê∞']; 
  const n=nextUnique([1,2,3,4,5,6,7,8,9,10],recentCounts); 
  pushRecent(recentCounts,n); 
  currentNumber=n;
  const w = window.innerWidth;
  const h = window.innerHeight;
  for(let i=0;i<n;i++){ 
    let x,y,k=0; 
    do{ 
      x=Math.random()*(w-120)+60; 
      y=Math.random()*(h-260)+140;  // leave room for title bars
      k++; 
    }while(k<120 && animals.some(a=>Math.hypot(a.x-x,a.y-y)<110*screenScale)); 
    animals.push(new Animal(x,y, types[(Math.random()*types.length)|0])); 
  }
  document.getElementById('title').textContent = `Count ${n} animals!`;
}

// ===== path helpers
function makeLine(x1,y1,x2,y2,seg=40){
  const pts=[]; for(let i=0;i<=seg;i++){ const t=i/seg; pts.push({x:x1+(x2-x1)*t, y:y1+(y2-y1)*t}); } return pts;
}
function makeArc(cx,cy,r,a0,a1,seg=72){
  const pts=[]; for(let i=0;i<=seg;i++){ const t=i/seg, a=a0+(a1-a0)*t; pts.push({x:cx+r*Math.cos(a), y:cy+r*Math.sin(a)});} return pts;
}
function concatStroke(...segs){
  const out=[]; for(const s of segs){ if(s && s.length) out.push(...s); } return out;
}
function makeQ(x0,y0,cx,cy,x1,y1,seg=48){
  const pts=[];
  for(let i=0;i<=seg;i++){
    const t=i/seg, mt=1-t;
    const x=mt*mt*x0 + 2*mt*t*cx + t*t*x1;
    const y=mt*mt*y0 + 2*mt*t*cy + t*t*y1;
    pts.push({x,y});
  }
  return pts;
}
function eightPath(cx, cy, rt, rb){
  // Create clean figure-8: two circles that touch at center
  const topY = cy - (rt + rb) * 0.4;  // Top circle center
  const botY = cy + (rt + rb) * 0.4;  // Bottom circle center
  
  return concatStroke(
    // Start at top of top circle, go clockwise around top circle
    makeArc(cx, topY, rt, -Math.PI/2, Math.PI/2),
    // Continue clockwise around bottom circle  
    makeArc(cx, botY, rb, Math.PI/2, -Math.PI/2),
    // Return to start point
    makeArc(cx, topY, rt, Math.PI/2, -Math.PI/2)
  );
}

// ===== glyphStrokes (original merged version) =====
// Returns Array<Stroke>; Stroke = Array<{x,y}>
function glyphStrokes(ch){
  const cx=window.innerWidth/2, cy=window.innerHeight/2;
  const s=120*screenScale;

  if(typeof ch==='number'){
    switch(ch){
      case 0: return [ concatStroke(
        // Create more oval/elongated shape for number 0
        makeArc(cx, cy-s*0.2, s*0.5, Math.PI, Math.PI*1.5),  // top left
        makeArc(cx, cy-s*0.2, s*0.5, Math.PI*1.5, 0),        // top right  
        makeArc(cx, cy+s*0.2, s*0.5, 0, Math.PI*0.5),        // bottom right
        makeArc(cx, cy+s*0.2, s*0.5, Math.PI*0.5, Math.PI)   // bottom left
      )];
      case 1: return [ concatStroke(
        makeLine(cx, cy - s*1.0, cx - s*0.25, cy - s*0.8),
        makeLine(cx, cy - s*1.0, cx, cy + s*0.85)
      )];
      case 2: return [ concatStroke(
        makeArc(cx, cy-s*0.35, s*0.55, Math.PI, Math.PI*2),
        makeLine(cx+s*0.55, cy-s*0.35, cx-s*0.55, cy+s*0.65),
        makeLine(cx-s*0.55, cy+s*0.65, cx+s*0.55, cy+s*0.65)
      )];
      case 3: return [ concatStroke(
        // Top horizontal line 
        makeLine(cx - s*0.35, cy - s*0.75, cx + s*0.35, cy - s*0.75),
        // Top right curve
        makeArc(cx + s*0.1, cy - s*0.4, s*0.35, -Math.PI*0.3, Math.PI*0.3),
        // Middle horizontal indent
        makeLine(cx + s*0.35, cy - s*0.05, cx + s*0.1, cy - s*0.05),
        // Bottom right curve  
        makeArc(cx + s*0.1, cy + s*0.4, s*0.35, -Math.PI*0.3, Math.PI*0.3),
        // Bottom horizontal line
        makeLine(cx + s*0.35, cy + s*0.75, cx - s*0.35, cy + s*0.75)
      )];
      case 4: return [
        makeLine(cx - s*0.4, cy - s*1.0, cx - s*0.4, cy - s*0.1),
        makeLine(cx - s*0.4, cy - s*0.1, cx + s*0.5, cy - s*0.1),
        makeLine(cx + s*0.5, cy - s*1.0, cx + s*0.5, cy + s*0.9),
      ];
      case 5: return [ concatStroke(
        // Start at top left, go down
        makeLine(cx - s*0.4, cy - s*0.9, cx - s*0.4, cy - s*0.1),
        // Horizontal line at top  
        makeLine(cx - s*0.4, cy - s*0.9, cx + s*0.4, cy - s*0.9),
        // Horizontal line at middle
        makeLine(cx - s*0.4, cy - s*0.1, cx + s*0.2, cy - s*0.1),
        // Bottom right curve
        makeArc(cx + s*0.2, cy + s*0.3, s*0.4, -Math.PI/2, Math.PI/2),
        // Bottom line back to left
        makeLine(cx + s*0.2, cy + s*0.7, cx - s*0.3, cy + s*0.7)
      )];
      case 6: return [ concatStroke(
        // Start at top, curve down and spiral into bottom loop
        makeArc(cx, cy - s*0.3, s*0.6, Math.PI*1.8, Math.PI*2.5),
        // Continue the spiral into the main circle
        makeArc(cx, cy + s*0.2, s*0.45, Math.PI*1.5, Math.PI*3.5)
      )];
      case 7: return [
        makeLine(cx - s*0.5, cy - s*1.0, cx + s*0.5, cy - s*1.0),
        makeLine(cx + s*0.5, cy - s*1.0, cx - s*0.3, cy + s*0.9),
      ];
      case 8: return [ eightPath(cx, cy, s*0.38, s*0.5) ];
      case 9: return [ concatStroke(
        makeArc(cx, cy - s*0.35, s*0.5, Math.PI*1.5, Math.PI*3.5),
        makeLine(cx + s*0.5, cy - s*0.35, cx + s*0.5, cy + s*0.9)
      )];
    }
  }

  const x = cx, y = cy;
  switch(ch){
    case 'A': return [
      makeLine(x, y-s*0.9, x-s*0.5, y+s*0.8),
      makeLine(x, y-s*0.9, x+s*0.5, y+s*0.8),
      makeLine(x-s*0.25, y - s*0.1, x+s*0.25, y - s*0.1),
    ];
    case 'B': return [ concatStroke(
      // Start with vertical line
      makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
      // Top horizontal line
      makeLine(x-s*0.45, y-s*0.9, x+s*0.25, y-s*0.9),
      // Top right curve
      makeArc(x+s*0.25, y-s*0.6, s*0.3, -Math.PI/2, Math.PI/2),
      // Middle connecting line
      makeLine(x+s*0.25, y-s*0.3, x-s*0.45, y-s*0.3),
      makeLine(x-s*0.45, y-s*0.3, x+s*0.3, y-s*0.3),
      // Bottom right curve  
      makeArc(x+s*0.3, y+s*0.15, s*0.45, -Math.PI/2, Math.PI/2),
      // Bottom horizontal line
      makeLine(x+s*0.3, y+s*0.6, x-s*0.45, y+s*0.9)
    )];
    case 'C': return [ makeArc(x, y, s*0.7, Math.PI*0.75, Math.PI*1.25) ];
    case 'D': return [
      concatStroke(
        makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
        makeLine(x-s*0.45, y+s*0.9, x+s*0.3, y+s*0.9),
        makeArc(x+s*0.3, y, s*0.9, Math.PI/2, -Math.PI/2),
        makeLine(x+s*0.3, y-s*0.9, x-s*0.45, y-s*0.9)
      ),
    ];
    case 'E': return [
      makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
      makeLine(x-s*0.45, y-s*0.9, x+s*0.45, y-s*0.9),
      makeLine(x-s*0.45, y, x+s*0.35, y),
      makeLine(x-s*0.45, y+s*0.9, x+s*0.45, y+s*0.9),
    ];
    case 'F': return [
      makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
      makeLine(x-s*0.45, y-s*0.9, x+s*0.45, y-s*0.9),
      makeLine(x-s*0.45, y, x+s*0.3, y),
    ];
    case 'G': return [ concatStroke(
      // Start at top right, curve around like a C
      makeArc(x, y, s*0.65, -Math.PI*0.25, Math.PI*1.25),
      // Horizontal line inward (the G's "bar")
      makeLine(x+s*0.46, y, x+s*0.25, y),
      // Small vertical line down
      makeLine(x+s*0.25, y, x+s*0.25, y+s*0.35)
    )];
    case 'H': return [
      makeLine(x-s*0.5, y-s*0.9, x-s*0.5, y+s*0.9),
      makeLine(x+s*0.5, y-s*0.9, x+s*0.5, y+s*0.9),
      makeLine(x-s*0.5, y, x+s*0.5, y),
    ];
    case 'I': return [
      makeLine(x, y-s*0.9, x, y+s*0.9),
      makeLine(x-s*0.25, y-s*0.9, x+s*0.25, y-s*0.9),
      makeLine(x-s*0.25, y+s*0.9, x+s*0.25, y+s*0.9),
    ];
    case 'J': return [
      concatStroke(
        makeLine(x+s*0.2, y-s*0.9, x+s*0.2, y),
        makeArc(x, y, s*0.2, 0, Math.PI, 36)
      ),
      makeLine(x-s*0.2, y-s*0.9, x+s*0.2, y-s*0.9),
    ];
    case 'K': return [
      makeLine(x-s*0.5, y-s*0.9, x-s*0.5, y+s*0.9),
      makeLine(x+s*0.4, y-s*0.9, x-s*0.5, y),
      makeLine(x-s*0.5, y, x+s*0.5, y+s*0.9),
    ];
    case 'L': return [ concatStroke(
      makeLine(x-s*0.5, y-s*0.9, x-s*0.5, y+s*0.9),
      makeQ(x-s*0.5, y+s*0.9, x-s*0.3, y+s*0.9, x-s*0.2, y+s*0.9, 8),
      makeLine(x-s*0.2, y+s*0.9, x+s*0.5, y+s*0.9)
    )];
    case 'M': return [
      makeLine(x-s*0.6, y-s*0.9, x-s*0.6, y+s*0.9),
      concatStroke(
        makeLine(x-s*0.6, y-s*0.9, x, y+s*0.9),
        makeLine(x, y+s*0.9, x+s*0.6, y-s*0.9),
        makeLine(x+s*0.6, y-s*0.9, x+s*0.6, y+s*0.9)
      ),
    ];
    case 'N': return [
      makeLine(x-s*0.6, y-s*0.9, x-s*0.6, y+s*0.9),
      concatStroke(
        makeLine(x-s*0.6, y-s*0.9, x+s*0.6, y+s*0.9),
        makeLine(x+s*0.6, y+s*0.9, x+s*0.6, y-s*0.9)
      ),
    ];
    case 'O': return [ makeArc(x, y, s*0.8, Math.PI*1.5, Math.PI*3.5) ];
    case 'P': return [
      makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
      concatStroke(
        makeLine(x-s*0.45, y-s*0.9, x+s*0.3, y-s*0.9),
        makeArc(x, y-s*0.35, s*0.35, -Math.PI/2, Math.PI/2),
        makeLine(x+s*0.3, y+s*0.2, x-s*0.45, y+s*0.2)
      ),
    ];
    case 'Q': return [
      makeArc(x, y, s*0.8, Math.PI*1.5, Math.PI*3.5),
      makeLine(x+s*0.2, y+s*0.4, x+s*0.5, y+s*1.0),
    ];
    case 'R': return [
      makeLine(x-s*0.45, y-s*0.9, x-s*0.45, y+s*0.9),
      concatStroke(
        makeLine(x-s*0.45, y-s*0.9, x+s*0.3, y-s*0.9),
        makeArc(x, y-s*0.35, s*0.35, -Math.PI/2, Math.PI/2),
        makeLine(x+s*0.3, y+s*0.2, x-s*0.45, y+s*0.2)
      ),
      makeLine(x-s*0.1, y+s*0.2, x+s*0.5, y+s*0.9),
    ];
    case 'S': {
      const p0x = x - s*0.35, p0y = y - s*0.6;
      const c1x = x - s*0.35, c1y = y - s*0.35;
      const p1x = x + s*0.35, p1y = y - s*0.05;
      const c2x = x + s*0.35, c2y = y + s*0.35;
      const p2x = x - s*0.35, p2y = y + s*0.6;
      return [ concatStroke(
        makeQ(p0x,p0y, c1x,c1y, p1x,p1y, 48),
        makeQ(p1x,p1y, c2x,c2y, p2x,p2y, 48)
      )];
    }
    case 'T': return [
      makeLine(x, y-s*0.9, x, y+s*0.9),
      makeLine(x-s*0.6, y-s*0.9, x+s*0.6, y-s*0.9),
    ];
    case 'U': return [ concatStroke(
      makeLine(x-s*0.5, y-s*0.9, x-s*0.5, y-s*0.1),
      makeArc(x, y-s*0.1, s*0.5, Math.PI, 0),
      makeLine(x+s*0.5, y-s*0.1, x+s*0.5, y-s*0.9)
    )];
    case 'V': return [ concatStroke(
      makeLine(x-s*0.6, y-s*0.9, x, y+s*0.9),
      makeLine(x, y+s*0.9, x+s*0.6, y-s*0.9)
    )];
    case 'W': return [ concatStroke(
      makeLine(x-s*0.7, y-s*0.9, x-s*0.35, y+s*0.9),
      makeLine(x-s*0.35, y+s*0.9, x, y-s*0.5),
      makeLine(x, y-s*0.5, x+s*0.35, y+s*0.9),
      makeLine(x+s*0.35, y+s*0.9, x+s*0.7, y-s*0.9)
    )];
    case 'X': return [
      makeLine(x-s*0.6, y-s*0.9, x+s*0.6, y+s*0.9),
      makeLine(x+s*0.6, y-s*0.9, x-s*0.6, y+s*0.9),
    ];
    case 'Y': return [
      makeLine(x-s*0.5, y-s*0.9, x, y),
      concatStroke(
        makeLine(x+s*0.5, y-s*0.9, x, y),
        makeLine(x, y, x, y+s*0.9)
      ),
    ];
    case 'Z': return [ concatStroke(
      makeLine(x-s*0.6, y-s*0.9, x+s*0.6, y-s*0.9),
      makeLine(x+s*0.6, y-s*0.9, x-s*0.6, y+s*0.9),
      makeLine(x-s*0.6, y+s*0.9, x+s*0.6, y+s*0.9)
    )];
  }

  const w=s*0.8,h=s*1.0;
  return [
    makeLine(cx-w/2, cy-h/2, cx+w/2, cy-h/2),
    makeLine(cx+w/2, cy-h/2, cx+w/2, cy+h/2),
    makeLine(cx+w/2, cy+h/2, cx-w/2, cy+h/2),
    makeLine(cx-w/2, cy+h/2, cx-w/2, cy-h/2),
  ];
}

// ===== tracing scene control =====
function buildTracing(ch){
  tracingStrokes = glyphStrokes(ch);
  strokeIdx = 0; pointIdx  = 0; completedStrokes = 0;
  const label = typeof ch==='number' ? ch : ch;
  document.getElementById('title').textContent = `Trace ${label}`;
}

function initTrace(){
  let ch;
  if(tracingSet==='numbers'){ 
    const choice=nextUnique([0,1,2,3,4,5,6,7,8,9],recentNumbers); 
    pushRecent(recentNumbers,choice); 
    ch=choice; 
    currentNumber=choice; 
  } else { 
    const choice=nextUnique(lettersList,recentLetters); 
    pushRecent(recentLetters,choice); 
    ch=choice; 
    currentLetter=lettersList.indexOf(choice); 
  }
  buildTracing(ch);
  document.getElementById('title').textContent = `Trace: ${ch}`;
  
  // Reset tracing state
  userStrokes = [];
  currentUserStroke = [];
  tracingCoverage = [];
  strokeIdx = 0;
  pointIdx = 0;
  completedStrokes = 0;
}

// ===== draw loop
function draw(){
  const g=ctx.createLinearGradient(0,0,0,window.innerHeight); 
  const hue=(Date.now()/60)%360;
  g.addColorStop(0,`hsl(${hue},50%,85%)`); 
  g.addColorStop(1,`hsl(${(hue+60)%360},50%,90%)`);
  ctx.fillStyle=g; 
  ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

  parts = parts.filter(p=>p.a>0); 
  parts.forEach(p=>{
    p.x+=p.vx; 
    p.y+=p.vy; 
    p.vy+=.25; 
    p.a-=.02; 
    p.r*=.985; 
    ctx.globalAlpha=Math.max(0,p.a); 
    ctx.fillStyle=p.c; 
    ctx.beginPath(); 
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2); 
    ctx.fill(); 
    ctx.globalAlpha=1;
  });

  if(mode==='count') drawCount();
  else if(mode==='trace') drawTrace();

  requestAnimationFrame(draw);
}

function drawCount(){
  animals.forEach(a=>a.draw());
  const done=animals.filter(a=>a.counted).length;
  ctx.fillStyle='#333'; 
  ctx.font=`bold ${Math.max(18, 28*screenScale)}px system-ui, Arial, sans-serif`; 
  ctx.textAlign='center';
  ctx.fillText(`${done} / ${currentNumber}`, window.innerWidth/2, window.innerHeight-36*screenScale);
  if(done===animals.length && animals.length){
    setTimeout(()=>{ 
      sOK(); 
      burst(window.innerWidth/2, window.innerHeight/2, 24); 
      addScore(10); 
      mode='trace'; 
      initTrace(); 
    },180);
  }
}

function drawHandStroke(pts, endIdx){
  for(let i=1; i<=endIdx && i<pts.length; i++){
    const t = i / pts.length;
    const w = (18 + 8*Math.sin(Math.PI*t)) * screenScale;
    ctx.lineWidth = w;
    ctx.beginPath();
    ctx.moveTo(pts[i-1].x, pts[i-1].y);
    ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
  }
}

function drawTrace(){
  if(!tracingStrokes.length) return;

  ctx.lineCap='round'; ctx.lineJoin='round';
  const strokeWidth = getStrokeWidth();
  const tolerance = getTolerance();

  // Draw light guide paths
  ctx.lineWidth = strokeWidth + 8;
  ctx.strokeStyle = 'rgba(200,200,200,.3)';
  for(const pts of tracingStrokes){
    if(!pts.length) continue;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
  }

  // Draw coverage indicators
  if(tracingCoverage.length === tracingStrokes.length) {
    for(let strokeIdx = 0; strokeIdx < tracingStrokes.length; strokeIdx++) {
      const targetStroke = tracingStrokes[strokeIdx];
      const coverage = tracingCoverage[strokeIdx];
      
      for(let i = 0; i < coverage.length; i++) {
        const pointIdx = i * SAMPLE_DISTANCE;
        if(pointIdx >= targetStroke.length) break;
        
        const point = targetStroke[pointIdx];
        ctx.fillStyle = coverage[i] ? 'rgba(76, 175, 80, 0.8)' : 'rgba(255, 87, 34, 0.4)';
        ctx.beginPath();
        ctx.arc(point.x, point.y, 4 * screenScale, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Draw user's pen strokes
  ctx.lineWidth = strokeWidth;
  ctx.strokeStyle = '#2196F3';
  for(const userStroke of userStrokes) {
    if(userStroke.length < 2) continue;
    ctx.beginPath();
    ctx.moveTo(userStroke[0].x, userStroke[0].y);
    for(let i = 1; i < userStroke.length; i++) {
      ctx.lineTo(userStroke[i].x, userStroke[i].y);
    }
    ctx.stroke();
  }
  
  // Draw current stroke being drawn
  if(currentUserStroke.length > 1) {
    ctx.lineWidth = strokeWidth;
    ctx.strokeStyle = '#1976D2';
    ctx.beginPath();
    ctx.moveTo(currentUserStroke[0].x, currentUserStroke[0].y);
    for(let i = 1; i < currentUserStroke.length; i++) {
      ctx.lineTo(currentUserStroke[i].x, currentUserStroke[i].y);
    }
    ctx.stroke();
  }

  // Draw start hints for uncovered strokes
  for(let i = 0; i < tracingStrokes.length; i++) {
    const pts = tracingStrokes[i];
    if(!pts.length) continue;
    
    const coverage = tracingCoverage[i] || [];
    const startCovered = coverage[0] || false;
    
    if(!startCovered) {
      ctx.fillStyle = '#4CAF50';
      ctx.beginPath();
      ctx.arc(pts[0].x, pts[0].y, 8 * screenScale, 0, Math.PI * 2);
      ctx.fill();
      
      // Add arrow indicating direction
      if(pts.length > 1) {
        const dx = pts[1].x - pts[0].x;
        const dy = pts[1].y - pts[0].y;
        const angle = Math.atan2(dy, dx);
        const arrowLength = 15 * screenScale;
        
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 3 * screenScale;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        ctx.lineTo(pts[0].x + Math.cos(angle) * arrowLength, pts[0].y + Math.sin(angle) * arrowLength);
        ctx.stroke();
      }
    }
  }
  
  // Draw progress indicator
  let totalCovered = 0;
  let totalSamples = 0;
  for (const coverage of tracingCoverage) {
    totalSamples += coverage.length;
    totalCovered += coverage.filter(c => c).length;
  }
  const progress = totalSamples > 0 ? totalCovered / totalSamples : 0;
  
  if(progress > 0) {
    const barWidth = 200 * screenScale;
    const barHeight = 8 * screenScale;
    const barX = window.innerWidth/2 - barWidth/2;
    const barY = window.innerHeight - 50 * screenScale;
    
    // Background
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(barX - 4, barY - 4, barWidth + 8, barHeight + 8);
    ctx.fillStyle = 'rgba(200,200,200,0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    // Progress
    ctx.fillStyle = progress >= COVERAGE_THRESHOLD ? '#4CAF50' : '#2196F3';
    ctx.fillRect(barX, barY, barWidth * progress, barHeight);
    
    // Text
    ctx.fillStyle = '#333';
    ctx.font = `${Math.max(12, 16 * screenScale)}px system-ui, Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.round(progress * 100)}%`, window.innerWidth/2, barY - 8 * screenScale);
  }
}

// Dynamic tolerance and step based on screen scale
function getTolerance() {
  return Math.max(12, Math.min(32, 20 * screenScale));
}

function getStrokeWidth() {
  return Math.max(8, Math.min(24, 16 * screenScale));
}

// Coverage detection settings
const COVERAGE_THRESHOLD = 0.85; // 85% coverage required
const SAMPLE_DISTANCE = 8; // Distance between coverage samples

// Enhanced tracing with coverage detection
function addToUserStroke(x, y) {
  if (currentUserStroke.length === 0 || 
      Math.hypot(x - currentUserStroke[currentUserStroke.length - 1].x, 
                 y - currentUserStroke[currentUserStroke.length - 1].y) > 2) {
    currentUserStroke.push({x, y});
  }
}

function finishUserStroke() {
  if (currentUserStroke.length > 1) {
    userStrokes.push([...currentUserStroke]);
    updateCoverage();
    currentUserStroke = [];
  }
}

function updateCoverage() {
  const tolerance = getTolerance();
  
  // Initialize coverage if needed
  if (tracingCoverage.length !== tracingStrokes.length) {
    tracingCoverage = tracingStrokes.map(stroke => new Array(Math.ceil(stroke.length / SAMPLE_DISTANCE)).fill(false));
  }
  
  // Check coverage for each target stroke
  for (let strokeIdx = 0; strokeIdx < tracingStrokes.length; strokeIdx++) {
    const targetStroke = tracingStrokes[strokeIdx];
    if (!targetStroke.length) continue;
    
    const coverage = tracingCoverage[strokeIdx];
    
    // Sample points along the target stroke
    for (let i = 0; i < targetStroke.length; i += SAMPLE_DISTANCE) {
      const sampleIdx = Math.floor(i / SAMPLE_DISTANCE);
      if (sampleIdx >= coverage.length) break;
      
      const targetPoint = targetStroke[i];
      
      // Check if any user stroke covers this point
      for (const userStroke of userStrokes) {
        for (const userPoint of userStroke) {
          const distance = Math.hypot(userPoint.x - targetPoint.x, userPoint.y - targetPoint.y);
          if (distance <= tolerance) {
            coverage[sampleIdx] = true;
            break;
          }
        }
        if (coverage[sampleIdx]) break;
      }
    }
  }
  
  checkCompletion();
}

function checkCompletion() {
  let totalCovered = 0;
  let totalSamples = 0;
  let strokesWithMinimumCoverage = 0;
  
  for (const coverage of tracingCoverage) {
    const strokeCovered = coverage.filter(c => c).length;
    const strokeTotal = coverage.length;
    totalSamples += strokeTotal;
    totalCovered += strokeCovered;
    
    // Each stroke needs at least 75% coverage
    if (strokeTotal > 0 && (strokeCovered / strokeTotal) >= 0.75) {
      strokesWithMinimumCoverage++;
    }
  }
  
  const coverageRatio = totalSamples > 0 ? totalCovered / totalSamples : 0;
  const allStrokesMinimumCovered = strokesWithMinimumCoverage === tracingStrokes.length;
  
  // Need both high overall coverage AND minimum coverage on each stroke
  if (coverageRatio >= COVERAGE_THRESHOLD && allStrokesMinimumCovered) {
    sOK();
    burst(window.innerWidth/2, window.innerHeight/2, 24);
    addScore(15);
    setTimeout(() => {
      tracingSet = (tracingSet==='numbers') ? 'letters' : 'numbers';
      mode = 'count';
      initCount();
    }, 1000);
  }
}

// input
function pos(e){ 
  const t=('touches' in e)?e.touches[0]:e; 
  const r=canvas.getBoundingClientRect(); 
  return {x:t.clientX-r.left, y:t.clientY-r.top}; 
}
function down(e){ 
  e.preventDefault(); 
  ensureAudio();
  const {x,y}=pos(e); 
  pointerDown=true; 
  if(mode==='count'){ 
    animals.forEach(a=>{ 
      if(!a.counted && a.hit(x,y)){ 
        a.counted=true; 
        sClick(); 
        burst(x,y,6);
      } 
    }); 
  }
  else if(mode==='trace'){ 
    currentUserStroke = [{x, y}];
  }
}
function move(e){ 
  if(!pointerDown) return; 
  if(mode==='trace'){ 
    const {x,y}=pos(e); 
    addToUserStroke(x, y);
  } 
}
function up(){ 
  if(mode==='trace' && pointerDown) {
    finishUserStroke();
  }
  pointerDown=false; 
}

canvas.addEventListener('mousedown',down); 
window.addEventListener('mouseup',up); 
canvas.addEventListener('mousemove',move);
canvas.addEventListener('touchstart',down,{passive:false}); 
window.addEventListener('touchend',up); 
canvas.addEventListener('touchmove',move,{passive:false});

function addScore(n){ score+=n; document.getElementById('score').textContent=score; }

function start(){ 
  score=0; 
  document.getElementById('score').textContent=score; 
  mode='count'; 
  initCount(); 
  draw(); 
}
start();
</script>
</body>
</html>
